---
title: Callback과 Promise와의 차이
description: Javascript에서 비동기 함수를 다룰 때 사용되는 Callback과 Promise의 차이를 알아보자
date: 2024-10-12
---

# Callback과 Promise

Callback과 Promise는 비동기 함수를 사용할 때 쓰이는 패턴이다.

## Callback

Callback은 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 하는 함수를 전달하는 방법이다.

```javascript
function foo(callback) {
  const output = 'Hello World';
  callback(output);
}

function bar(str) {
  console.log(str);
}

foo(bar);
```

그런데 Callback은 **콜백 헬**로 인해 가독성이 나빠지고, **비동기 처리 중 발생한 에러 처리**가 힘들며 여러 개의 비동기 처리를 한 번에 하는데 한계가 있다.

### 콜백 헬

비동기 함수에 전달된 콜백 함수의 비동기 처리 결과에 대해 다시 후속 처리가 필요할 경우 콜백 함수가 중첩되어 복잡도가 높아지는 현상을 콜백 헬이라고한다.  
콜백 헬은 가독성을 나쁘게 하며 실수를 유발하는 원인이 된다.

### 콜백 패턴에서 에러 처리가 힘든 이유

try 코드 블록 내에서 호출한 비동기 함수의 콜백 함수에서 발생한 에러는 catch 블록에서 캐치되지 않는다.  
비동기 함수는 콜백 함수가 호출되는 것을 기다리지 않고 즉시 종료되어 콜 스택에서 제거되므로 호출자 방향으로 전파되는 에러가 캐치되지 않기 때문이다.

## Promise

ES6에서 비동기 처리를 위한 또 다른 패턴으로 도입되었다.  
Promise는 Callback의 단점을 보완하고 비동기 처리 시점을 명확히 표현할 수 있다.

### 프로미스 체이닝

Promise의 then, catch, finally 후속 처리 메서드는 항상 Promise를 반환하므로 연속적으로 호출할 수 있다.  
이를 프로미스 체이닝이라고 하며, Promise는 프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속 처리를 하므로 비동기 처리를 위한 콜백 패턴에서 발생하던 콜백 헬이 발생하지 않는다.
다만 프로미스도 콜백 패턴을 사용하므로 콜백 함수를 사용하지 않는 것은 아니다. 따라서 여전히 가독성이 좋지는 않지만, ES8에서 도입된 async/await를 통해 해결할 수 있다.

### 프로미스의 에러 처리

비동기 처리 결과에 대한 후속처리는 then, catch, finally를 사용해 수행한다.
이때 비동기 처리에서 발생한 에러는 then 메서드의 두 번째 콜백 함수나 catch메서드를 사용해 처리할 수 있다.
다만 then(onResolved, onRejected)는 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져 가독성이 나빠지므로 catch 메서드를 사용해서 에러 처리를 하는 것을 권장한다.
